// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Aggregator extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Aggregator entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Aggregator must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Aggregator", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Aggregator | null {
    return changetype<Aggregator | null>(store.get_in_block("Aggregator", id));
  }

  static load(id: string): Aggregator | null {
    return changetype<Aggregator | null>(store.get("Aggregator", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get description(): string {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }

  get organizations(): OrganizationLoader {
    return new OrganizationLoader(
      "Aggregator",
      this.get("id")!.toString(),
      "organizations"
    );
  }
}

export class Organization extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Organization entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Organization must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Organization", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Organization | null {
    return changetype<Organization | null>(
      store.get_in_block("Organization", id)
    );
  }

  static load(id: string): Organization | null {
    return changetype<Organization | null>(store.get("Organization", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get aggregator(): string {
    let value = this.get("aggregator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set aggregator(value: string) {
    this.set("aggregator", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get description(): string {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }

  get proposals(): UnifiedOneStopShopLoader {
    return new UnifiedOneStopShopLoader(
      "Organization",
      this.get("id")!.toString(),
      "proposals"
    );
  }
}

export class UnifiedOneStopShop extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UnifiedOneStopShop entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UnifiedOneStopShop must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UnifiedOneStopShop", id.toString(), this);
    }
  }

  static loadInBlock(id: string): UnifiedOneStopShop | null {
    return changetype<UnifiedOneStopShop | null>(
      store.get_in_block("UnifiedOneStopShop", id)
    );
  }

  static load(id: string): UnifiedOneStopShop | null {
    return changetype<UnifiedOneStopShop | null>(
      store.get("UnifiedOneStopShop", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get organization(): string | null {
    let value = this.get("organization");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set organization(value: string | null) {
    if (!value) {
      this.unset("organization");
    } else {
      this.set("organization", Value.fromString(<string>value));
    }
  }

  get metadataContract(): Bytes | null {
    let value = this.get("metadataContract");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set metadataContract(value: Bytes | null) {
    if (!value) {
      this.unset("metadataContract");
    } else {
      this.set("metadataContract", Value.fromBytes(<Bytes>value));
    }
  }

  get title(): string {
    let value = this.get("title");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set title(value: string) {
    this.set("title", Value.fromString(value));
  }

  get description(): string {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get marketName(): string {
    let value = this.get("marketName");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set marketName(value: string) {
    this.set("marketName", Value.fromString(value));
  }

  get displayNameEvent(): string {
    let value = this.get("displayNameEvent");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set displayNameEvent(value: string) {
    this.set("displayNameEvent", Value.fromString(value));
  }

  get displayNameQuestion(): string {
    let value = this.get("displayNameQuestion");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set displayNameQuestion(value: string) {
    this.set("displayNameQuestion", Value.fromString(value));
  }

  get resolutionDate(): BigInt {
    let value = this.get("resolutionDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set resolutionDate(value: BigInt) {
    this.set("resolutionDate", Value.fromBigInt(value));
  }

  get createdAtTimestamp(): BigInt {
    let value = this.get("createdAtTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdAtTimestamp(value: BigInt) {
    this.set("createdAtTimestamp", Value.fromBigInt(value));
  }

  get companyToken(): string {
    let value = this.get("companyToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set companyToken(value: string) {
    this.set("companyToken", Value.fromString(value));
  }

  get currencyToken(): string {
    let value = this.get("currencyToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set currencyToken(value: string) {
    this.set("currencyToken", Value.fromString(value));
  }

  get poolConditionalYes(): string | null {
    let value = this.get("poolConditionalYes");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set poolConditionalYes(value: string | null) {
    if (!value) {
      this.unset("poolConditionalYes");
    } else {
      this.set("poolConditionalYes", Value.fromString(<string>value));
    }
  }

  get poolConditionalNo(): string | null {
    let value = this.get("poolConditionalNo");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set poolConditionalNo(value: string | null) {
    if (!value) {
      this.unset("poolConditionalNo");
    } else {
      this.set("poolConditionalNo", Value.fromString(<string>value));
    }
  }

  get poolExpectedYes(): string | null {
    let value = this.get("poolExpectedYes");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set poolExpectedYes(value: string | null) {
    if (!value) {
      this.unset("poolExpectedYes");
    } else {
      this.set("poolExpectedYes", Value.fromString(<string>value));
    }
  }

  get poolExpectedNo(): string | null {
    let value = this.get("poolExpectedNo");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set poolExpectedNo(value: string | null) {
    if (!value) {
      this.unset("poolExpectedNo");
    } else {
      this.set("poolExpectedNo", Value.fromString(<string>value));
    }
  }

  get poolPredictionYes(): string | null {
    let value = this.get("poolPredictionYes");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set poolPredictionYes(value: string | null) {
    if (!value) {
      this.unset("poolPredictionYes");
    } else {
      this.set("poolPredictionYes", Value.fromString(<string>value));
    }
  }

  get poolPredictionNo(): string | null {
    let value = this.get("poolPredictionNo");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set poolPredictionNo(value: string | null) {
    if (!value) {
      this.unset("poolPredictionNo");
    } else {
      this.set("poolPredictionNo", Value.fromString(<string>value));
    }
  }
}

export class TokenInfo extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TokenInfo entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TokenInfo must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TokenInfo", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TokenInfo | null {
    return changetype<TokenInfo | null>(store.get_in_block("TokenInfo", id));
  }

  static load(id: string): TokenInfo | null {
    return changetype<TokenInfo | null>(store.get("TokenInfo", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get decimals(): BigInt {
    let value = this.get("decimals");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set decimals(value: BigInt) {
    this.set("decimals", Value.fromBigInt(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }
}

export class NormalizedPool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NormalizedPool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NormalizedPool must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NormalizedPool", id.toString(), this);
    }
  }

  static loadInBlock(id: string): NormalizedPool | null {
    return changetype<NormalizedPool | null>(
      store.get_in_block("NormalizedPool", id)
    );
  }

  static load(id: string): NormalizedPool | null {
    return changetype<NormalizedPool | null>(store.get("NormalizedPool", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get baseToken(): string {
    let value = this.get("baseToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set baseToken(value: string) {
    this.set("baseToken", Value.fromString(value));
  }

  get quoteToken(): string {
    let value = this.get("quoteToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set quoteToken(value: string) {
    this.set("quoteToken", Value.fromString(value));
  }

  get isBaseToken0(): boolean {
    let value = this.get("isBaseToken0");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isBaseToken0(value: boolean) {
    this.set("isBaseToken0", Value.fromBoolean(value));
  }

  get currentPrice(): BigDecimal {
    let value = this.get("currentPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set currentPrice(value: BigDecimal) {
    this.set("currentPrice", Value.fromBigDecimal(value));
  }

  get volume24h(): BigDecimal {
    let value = this.get("volume24h");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set volume24h(value: BigDecimal) {
    this.set("volume24h", Value.fromBigDecimal(value));
  }

  get candles(): UnifiedCandleLoader {
    return new UnifiedCandleLoader(
      "NormalizedPool",
      this.get("id")!.toString(),
      "candles"
    );
  }

  get trades(): UnifiedTradeLoader {
    return new UnifiedTradeLoader(
      "NormalizedPool",
      this.get("id")!.toString(),
      "trades"
    );
  }
}

export class UnifiedCandle extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UnifiedCandle entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UnifiedCandle must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UnifiedCandle", id.toString(), this);
    }
  }

  static loadInBlock(id: string): UnifiedCandle | null {
    return changetype<UnifiedCandle | null>(
      store.get_in_block("UnifiedCandle", id)
    );
  }

  static load(id: string): UnifiedCandle | null {
    return changetype<UnifiedCandle | null>(store.get("UnifiedCandle", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get time(): BigInt {
    let value = this.get("time");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set time(value: BigInt) {
    this.set("time", Value.fromBigInt(value));
  }

  get period(): i32 {
    let value = this.get("period");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set period(value: i32) {
    this.set("period", Value.fromI32(value));
  }

  get open(): BigDecimal {
    let value = this.get("open");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set open(value: BigDecimal) {
    this.set("open", Value.fromBigDecimal(value));
  }

  get high(): BigDecimal {
    let value = this.get("high");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set high(value: BigDecimal) {
    this.set("high", Value.fromBigDecimal(value));
  }

  get low(): BigDecimal {
    let value = this.get("low");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set low(value: BigDecimal) {
    this.set("low", Value.fromBigDecimal(value));
  }

  get close(): BigDecimal {
    let value = this.get("close");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set close(value: BigDecimal) {
    this.set("close", Value.fromBigDecimal(value));
  }

  get volume(): BigDecimal {
    let value = this.get("volume");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set volume(value: BigDecimal) {
    this.set("volume", Value.fromBigDecimal(value));
  }
}

export class UnifiedTrade extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UnifiedTrade entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UnifiedTrade must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UnifiedTrade", id.toString(), this);
    }
  }

  static loadInBlock(id: string): UnifiedTrade | null {
    return changetype<UnifiedTrade | null>(
      store.get_in_block("UnifiedTrade", id)
    );
  }

  static load(id: string): UnifiedTrade | null {
    return changetype<UnifiedTrade | null>(store.get("UnifiedTrade", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get type(): string {
    let value = this.get("type");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set type(value: string) {
    this.set("type", Value.fromString(value));
  }

  get price(): BigDecimal {
    let value = this.get("price");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set price(value: BigDecimal) {
    this.set("price", Value.fromBigDecimal(value));
  }

  get amountBase(): BigDecimal {
    let value = this.get("amountBase");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amountBase(value: BigDecimal) {
    this.set("amountBase", Value.fromBigDecimal(value));
  }

  get amountQuote(): BigDecimal {
    let value = this.get("amountQuote");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amountQuote(value: BigDecimal) {
    this.set("amountQuote", Value.fromBigDecimal(value));
  }

  get maker(): Bytes {
    let value = this.get("maker");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set maker(value: Bytes) {
    this.set("maker", Value.fromBytes(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }
}

export class PoolLookup extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PoolLookup entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PoolLookup must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PoolLookup", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PoolLookup | null {
    return changetype<PoolLookup | null>(store.get_in_block("PoolLookup", id));
  }

  static load(id: string): PoolLookup | null {
    return changetype<PoolLookup | null>(store.get("PoolLookup", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }
}

export class OrganizationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Organization[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Organization[]>(value);
  }
}

export class UnifiedOneStopShopLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): UnifiedOneStopShop[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<UnifiedOneStopShop[]>(value);
  }
}

export class UnifiedCandleLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): UnifiedCandle[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<UnifiedCandle[]>(value);
  }
}

export class UnifiedTradeLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): UnifiedTrade[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<UnifiedTrade[]>(value);
  }
}
