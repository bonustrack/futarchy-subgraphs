# Hypothetical Unified Schema

type Aggregator @entity(immutable: false) {
  id: ID! # Contract Address
  name: String!
  description: String!
  metadata: String
  metadataURI: String
  creator: Bytes!
  createdAt: BigInt!
  organizations: [Organization!]! @derivedFrom(field: "aggregator")
}

type Organization @entity(immutable: false) {
  id: ID! # Contract Address
  aggregator: Aggregator!
  name: String!
  description: String!
  metadata: String
  metadataURI: String
  owner: Bytes!
  createdAt: BigInt!
  proposals: [UnifiedOneStopShop!]! @derivedFrom(field: "organization")
}

type UnifiedOneStopShop @entity(immutable: false) {
  id: ID! # Proposal Address (Trading Contract)

  # Hierarchy (Nullable because a proposal might exist without metadata initially, or vice versa)
  organization: Organization
  metadataContract: Bytes # Address of the metadata contract

  # Metadata
  title: String!
  description: String!
  metadata: String
  metadataURI: String
  marketName: String!
  displayNameEvent: String!
  displayNameQuestion: String!
  resolutionDate: BigInt!
  createdAtTimestamp: BigInt!

  # The Tokens
  companyToken: TokenInfo!
  currencyToken: TokenInfo!

  # Wrapped Outcomes (For debugging and linking)
  outcomeYesCompany: String
  outcomeNoCompany: String
  outcomeYesCurrency: String
  outcomeNoCurrency: String

  # The 6 Pools
  poolConditionalYes: NormalizedPool
  poolConditionalNo: NormalizedPool
  poolExpectedYes: NormalizedPool
  poolExpectedNo: NormalizedPool
  poolPredictionYes: NormalizedPool
  poolPredictionNo: NormalizedPool
}

type TokenInfo @entity(immutable: false) {
  id: ID!
  symbol: String!
  decimals: BigInt!
  name: String!
}

type NormalizedPool @entity(immutable: false) {
  id: ID! # Pool Address

  # Reverse lookup to proposal (for age-based candle tiering)
  proposal: UnifiedOneStopShop

  # Basic Info
  baseToken: TokenInfo!
  quoteToken: TokenInfo!

  # Internal: to know if we need to invert
  isBaseToken0: Boolean!

  # Current State
  currentPrice: BigDecimal!
  volume24h: BigDecimal!
}

# Needed for linking logic
type PoolLookup @entity(immutable: false) {
  id: ID! # Pool Address
  pool: NormalizedPool!
}
