# Hypothetical Unified Schema

type Aggregator @entity(immutable: false) {
  id: ID! # Contract Address
  name: String!
  description: String!
  creator: Bytes!
  createdAt: BigInt!
  organizations: [Organization!]! @derivedFrom(field: "aggregator")
}

type Organization @entity(immutable: false) {
  id: ID! # Contract Address
  aggregator: Aggregator!
  name: String!
  description: String!
  owner: Bytes!
  createdAt: BigInt!
  proposals: [UnifiedOneStopShop!]! @derivedFrom(field: "organization")
}

type UnifiedOneStopShop @entity(immutable: false) {
  id: ID! # Proposal Address (Trading Contract)

  # Hierarchy (Nullable because a proposal might exist without metadata initially, or vice versa)
  organization: Organization
  metadataContract: Bytes # Address of the metadata contract

  # Metadata
  title: String!
  description: String!
  marketName: String!
  displayNameEvent: String!
  displayNameQuestion: String!
  resolutionDate: BigInt!
  createdAtTimestamp: BigInt!

  # The Tokens
  companyToken: TokenInfo!
  currencyToken: TokenInfo!

  # Wrapped Outcomes (For debugging and linking)
  outcomeYesCompany: String
  outcomeNoCompany: String
  outcomeYesCurrency: String
  outcomeNoCurrency: String

  # The 6 Pools
  poolConditionalYes: NormalizedPool
  poolConditionalNo: NormalizedPool
  poolExpectedYes: NormalizedPool
  poolExpectedNo: NormalizedPool
  poolPredictionYes: NormalizedPool
  poolPredictionNo: NormalizedPool
}

type TokenInfo @entity(immutable: false) {
  id: ID!
  symbol: String!
  decimals: BigInt!
  name: String!
}

type NormalizedPool @entity(immutable: false) {
  id: ID! # Pool Address

  # Reverse lookup to proposal (for age-based candle tiering)
  proposal: UnifiedOneStopShop

  # Basic Info
  baseToken: TokenInfo!
  quoteToken: TokenInfo!

  # Internal: to know if we need to invert
  isBaseToken0: Boolean!

  # Current State
  currentPrice: BigDecimal!
  volume24h: BigDecimal!

  # Candles
  candles: [UnifiedCandle!]! @derivedFrom(field: "pool")

  # Recent Trades
  trades: [UnifiedTrade!]! @derivedFrom(field: "pool")
}

type UnifiedCandle @entity(immutable: false) {
  id: ID! # poolId + period
  pool: NormalizedPool!
  time: BigInt!
  period: Int! # e.g. 3600
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  volume: BigDecimal!
}

type UnifiedTrade @entity(immutable: true) {
  id: ID!
  pool: NormalizedPool!
  timestamp: BigInt!
  type: String! # BUY or SELL
  price: BigDecimal!
  amountBase: BigDecimal!
  amountQuote: BigDecimal!
  maker: Bytes!
  txHash: Bytes!
}

# Needed for linking logic
type PoolLookup @entity(immutable: false) {
  id: ID! # Pool Address
  pool: NormalizedPool!
}
